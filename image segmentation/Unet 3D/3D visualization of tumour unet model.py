# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RncG_nQuWM8mAHSMdp0QE9J7QgylRq1g
"""

from keras.models import load_model
my_modeld = load_model('/content/drive/MyDrive/archive (11)/pf3new_newbrats_3d.hdf5',compile=False)

import os
import numpy as np
#import tensorflow as tf
import keras
from matplotlib import pyplot as plt
import glob
import random

! pip install plotly scikit-image

img_num = 100


test_img = np.load("/content/drive/MyDrive/archive (11)/BraTS2020_TrainingData/input_data_128/val/images/image_"+str(img_num)+".npy")

test_mask = np.load("/content/drive/MyDrive/archive (11)/BraTS2020_TrainingData/input_data_128/val/masks/mask_"+str(img_num)+".npy")
test_mask_argmax=np.argmax(test_mask, axis=3)

test_img_input = np.expand_dims(test_img, axis=0)
test_prediction = my_modeld.predict(test_img_input)
test_prediction_argmax=np.argmax(test_prediction, axis=4)[0,:,:,:]


# print(test_prediction_argmax.shape)
# print(test_mask_argmax.shape)
# print(np.unique(test_prediction_argmax))


#Plot individual slices from test predictions for verification
from matplotlib import pyplot as plt
import random

#n_slice=random.randint(0, test_prediction_argmax.shape[2])
n_slice = 55
plt.figure(figsize=(12, 8))
plt.subplot(231)
plt.title('Testing Image')
plt.imshow(test_img[:,:,n_slice,1], cmap='gray')
plt.subplot(232)
plt.title('Testing Label')
plt.imshow(test_mask_argmax[:,:,n_slice])
plt.subplot(233)
plt.title('Prediction on test image')
plt.imshow(test_prediction_argmax[:,:, n_slice])
plt.show()

import numpy as np
import plotly.graph_objects as go
from skimage.measure import marching_cubes
from scipy.ndimage import label

img_num = 100
test_img = np.load("/content/drive/MyDrive/archive (11)/BraTS2020_TrainingData/input_data_128/val/images/image_"+str(img_num)+".npy")
test_mask = np.load("/content/drive/MyDrive/archive (11)/BraTS2020_TrainingData/input_data_128/val/masks/mask_"+str(img_num)+".npy")
test_mask_argmax = np.argmax(test_mask, axis=3)
test_img_input = np.expand_dims(test_img, axis=0)
test_prediction = my_modeld.predict(test_img_input)
test_prediction_argmax = np.argmax(test_prediction, axis=4)[0]
voxel_volume =0.1
# Calculate the volume of the tumor
tumor_volume = np.sum(test_prediction_argmax == 1) * voxel_volume

# Create 3D surface plots of the original mask and predicted mask
def create_surface_plot(mask):
    vertices, faces, _, _ = marching_cubes(mask, level=0.5)
    x, y, z = vertices.T
    i, j, k = faces.T
    mesh = go.Mesh3d(x=x, y=y, z=z, i=i, j=j, k=k, opacity=0.5)
    return mesh

original_mask_surface = create_surface_plot(test_mask_argmax)
predicted_mask_surface = create_surface_plot(test_prediction_argmax)

# Create a figure and add the surfaces to it
fig = go.Figure(data=[original_mask_surface, predicted_mask_surface])

# Set the layout for the 3D graph
fig.update_layout(
    scene=dict(
        xaxis_title='X Axis',
        yaxis_title='Y Axis',
        zaxis_title='Z Axis',
    ),
    title='Original Mask and Predicted Mask 3D Surface Plots',
)

# Show the 3D graph
fig.show()

print(f"Volume of the tumor: {tumor_volume:.2f} cubic units")

import numpy as np
import plotly.graph_objs as go
from skimage.measure import marching_cubes

# Replace 'test_prediction_argmax' with your predicted 3D mask
predicted_mask = test_prediction_argmax == 1

# Use marching cubes algorithm to extract the surface vertices and faces
vertices, faces, _, _ = marching_cubes(predicted_mask, level=0.5)

# Create the 3D surface plot for the predicted mask
trace = go.Mesh3d(
    x=vertices[:, 0],
    y=vertices[:, 1],
    z=vertices[:, 2],
    i=faces[:, 0],
    j=faces[:, 1],
    k=faces[:, 2],
    opacity=0.5,  # Adjust the opacity of the surface plot
    color='rgba(255, 0, 0, 0.5)',  # Specify the color of the surface plot
)

# Set the layout for the 3D graph
layout = go.Layout(
    scene=dict(
        xaxis=dict(title='X Axis'),
        yaxis=dict(title='Y Axis'),
        zaxis=dict(title='Z Axis'),
    )
)

# Create the figure and add the trace to it
fig = go.Figure(data=[trace], layout=layout)

# Show the 3D graph
fig.show(figsize=(5, 8))

voxel_volume =0.1
# Calculate the volume of the tumor
tumor_volume = np.sum(test_prediction_argmax == 1) * voxel_volume
print(tumor_volume)

import cv2
import numpy as np

# Load the 2D image (replace 'your_image_path.jpg' with the actual image path)
image_path = '/content/Hirnmetastase_MRT-T1_KM.jpg'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)  # Read the image in grayscale

# Resize the 2D image to 128x128
resized_image = cv2.resize(image, (128, 128))

# Stack the resized 2D image along the depth axis to create a 3D volume
depth = 128
image_3d = np.stack([resized_image] * depth, axis=-1)

# Display the 3D image shape
print(image_3d.shape)  # Output: (128, 128, 128)

# Now image_3d is a 3D NumPy array representing the same image repeated across the depth axis.

temp_combined_images = np.stack((image_3d,)*3, axis=-1)

test_img=temp_combined_images

test_img_input = np.expand_dims(test_img, axis=0)
test_prediction = my_modeld.predict(test_img_input)
test_prediction_argmax = np.argmax(test_prediction, axis=4)[0]
voxel_volume =0.1
# Calculate the volume of the tumor
tumor_volume = np.sum(test_prediction_argmax == 1) * voxel_volume

# Create 3D surface plots of the original mask and predicted mask
def create_surface_plot(mask):
    vertices, faces, _, _ = marching_cubes(mask, level=0.5)
    x, y, z = vertices.T
    i, j, k = faces.T
    mesh = go.Mesh3d(x=x, y=y, z=z, i=i, j=j, k=k, opacity=0.5)
    return mesh

# original_mask_surface = create_surface_plot(test_mask_argmax)
predicted_mask_surface = create_surface_plot(test_prediction_argmax)

# Create a figure and add the surfaces to it
fig = go.Figure(data=[predicted_mask_surface])

# Set the layout for the 3D graph
fig.update_layout(
    scene=dict(
        xaxis_title='X Axis',
        yaxis_title='Y Axis',
        zaxis_title='Z Axis',
    ),
    title=' Predicted Mask 3D Surface Plots',
)

# Show the 3D graph
fig.show()

print(f"Volume of the tumor: {tumor_volume:.2f} cubic units")

